###
while (1) {
    j = 0;
    counter++;
    fread(temp, 1, 1, ocd);

    while (*temp >= 128) {
        (*value)[j] = *temp;
        fread(temp, 1, 1, ocd);
        j++;
        counter++;
    }

    if (feof(ocd)) {
        printf("counter : %d\n", counter);
        break;
    }

    (*value)[j] = *temp;
    const uint8_t** val_cp = (const uint8_t**)value;

    uint32_t uncode = decode_varint(val_cp);
    fprintf(odd, "%d\n", uncode);
}
###
heap* heap_create(int maxsize)
{
    heap* h;
    h = (heap*)malloc(sizeof(*h));

    if (h != NULL) {
        h->maxsize = maxsize;
        h->nnodes = 0;
        h->nodes = (heapnode*)malloc(sizeof(*h->nodes) * (maxsize + 1));
        h->pos = (int*)calloc((maxsize + 1), sizeof(int));

        if (h->nodes == NULL) {
            free(h);
            return NULL;
        }
    }
    return h;
}
###
int int_vector_reserve(IntVector* v, size_t new_capacity)
{
    int* check = NULL;

    if (v != NULL && new_capacity > v->capacity && new_capacity > 0) {
        check = (int*)realloc(v->arr, new_capacity * sizeof(int));

        if (check != NULL)
            v->arr = check;

        if (v->arr == NULL)
            return -1;
        v->capacity = new_capacity;
        return 0;
    } else
        return -1;
}
###
void bstree_add(struct bstree* tree, char* key, int value)
{
    if (tree == NULL)
        return;
    struct bstree *parent, *node;
    while (tree != NULL) {
        parent = tree;
        if (0 > strcmp(key, tree->key))
            tree = tree->left;
        else if (0 < strcmp(key, tree->key))
            tree = tree->right;
        else
            return;
    }
    node = bstree_create(key, value);
    if (0 > strcmp(key, parent->key))
        parent->left = node;
    else
        parent->right = node;
}
###
struct bstree* find_child(struct bstree* tree, char* key, int* a)
{
    if (tree == NULL)
        return NULL;
    struct bstree *child, *node;
    node = bstree_lookup(tree, key);
    child = node->left;
    *a = 0;
    if (child != NULL) {
        *a = *a + 1;
        return child;
    }
    child = node->right;
    if (child != NULL) {
        *a = *a + 2;
        return child;
    }
}
###
struct bstree* find_parent(struct bstree* tree, char* key, int* side)
{
    if (tree == NULL)
        return NULL;
    struct bstree* parent;
    while (tree != NULL) {
        if (0 == strcmp(key, tree->key)) {
            tree = parent;
            return tree;
        }
        parent = tree;
        if (0 > strcmp(key, tree->key)) {
            tree = tree->left;
            *side = 1;
        } else {
            tree = tree->right;
            *side = 0;
        }
    }
    return tree;
}
###
void bstree_delete(struct bstree* tree, char* key)
{
    if (tree == NULL)
        return;
    struct bstree *parent, *node, *child, *node2;
    int *side, *side2;
    int b = 0, a = 2;
    side = &a;
    side2 = &b;
    node = bstree_lookup(tree, key);
    parent = find_parent(tree, key, side);
    child = find_child(tree, key, side2);
    printf("%d", b);

    if (b == 3) {
        node2 = bstree_min(node->right);
        node = node2;
        parent = find_parent(tree, node2->key, side);
        parent->left = node2->left;
        free(node2);
    }

    if (b == 2) {
        free(node);
        parent->right = child;
        return;
    }
}
###
int main()
{
    struct bstree *tree, *node;

    char* str[200000];
    double time1, time2, time;
    FILE* f;
    int* a;
    int b = 10;
    a = &b;
    char* c;
    int N = 237742;
    f = fopen("text.txt", "r");
    for (int i = 0; i < 200000; i++) {
        str[i] = malloc(128);
        fscanf(f, "%127s", str[i]);
    }
    tree = bstree_create("bstree", 100);
    for (int i = 1; i < 200000; i++) {
        bstree_add(tree, str[i - 1], i - 1);
    }
    time1 = wtime();
    node = bstree_max(tree);
    time2 = wtime();
    time = time2 - time1;
}
###
#include <iostream>

using namespace std;

int main()
{
    int* m;

    m = (int*)malloc(10 * 10 * sizeof(int));

    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            *(m + i * 10 + j) = 0;
        }
    }

    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            cout << *(m + i * 10 + j) << " ";
            if (j == 9)
                cout << "\n";
        }
    }

    return 0;
}
###
#include <iostream>

using namespace std;

int main()
{
    int** m;
    int i, j;

    m = (int**)malloc(10 * sizeof(int*));

    for (i = 0; i < 10; i++) {
        m[i] = (int*)malloc(10 * sizeof(int));
    }

    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            m[i][j] = 0;
        }
    }

    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            cout << m[i][j] << "  ";
            if (j == 9)
                cout << "\n";
        }
    }

    return 0;
}
###
#include <stdio.h>
#include <stdlib.h>

int main()
{
    int i = 0;
    char** words = NULL;
    words = (char**)malloc(20 * sizeof(char*));

    FILE *str, *out;
    str = fopen("text.txt", "r");

    while (!feof(str)) {
        words[i] = (char*)malloc(25 * sizeof(char));
        fgets(words[i], 25, str);
        i++;
    }

    fclose(str);

    out = fopen("write.txt", "w");

    for (int j = 0; j < 10; j++) {
        fprintf(out, "%s", words[j]);
    }
}
###
#include <fstream>
#include <iostream>

using namespace std;

int main()
{
    unsigned int counter = 0;

    char** words = (char**)malloc(20 * sizeof(char*));

    ifstream in;
    in.open("symbols.txt");

    ofstream out;
    out.open("written.txt");

    while (in) {
        cout << counter << "\n";
        words[counter] = (char*)malloc(20 * sizeof(char));
        if (in.eof())
            break;
        in.getline(words[counter], 15);
        out << words[counter] << "\n";

        counter++;
    }

    in.close();
    out.close();

    cout << "REZ : " << words[0] << "\n";

    free(words);
}
###