###
unsigned int JenkinsHash(char *s)
{
    unsigned int h = 0;
    while (*s) {
        h += (unsigned int)*s++;
        h += (h << 10);
        h ^= (h >> 6);
    }
    h += (h << 3);
    h ^= (h >> 11);
    h += (h << 15);
    return h % HASHTAB_SIZE;
}
###
struct listnode *hashtab_lookup(struct listnode **hashtab,char *key)
{
    struct listnode *node;

    int index = JenkinsHash(key);
    for (node = hashtab[index]; node != NULL; node = node->next) {
        if(0 == strcmp(node->key,key))
            return node;
    }
    return NULL;
}
###
int main()
{   
    struct listnode *node;
    char *str[200000];
    int *a;
    int k = 0;
    a = &k;
    FILE *f;
    double time1,time2,time;
    f = fopen("text.txt", "r");
    for(int i = 0;i < 200000;i++){
        str[i] = malloc(128);
        fscanf(f,"%127s",str[i]);
    }
    hashtab_init(hashtab);
    for(int i = 0;i < 200000;i++){
        hashtab_add(hashtab,str[i],i,a);
    }
    time1 = wtime();
    node = hashtab_lookup(hashtab,"languente");
    time2 = wtime();
    time = time2 - time1;
    printf("%s\n",node->key);
    printf("%d\n",k);
    printf("%.9lf\n",time);
    return 0;
}
###
    void bstree_add(struct bstree *tree,char *key,int value)
    {
        if (tree == NULL)
            return;
        struct bstree *parent, *node;
        while (tree != NULL) {
            parent = tree;
            if(0 > strcmp(key,tree->key))
                tree = tree->left;
            else if(0 < strcmp(key,tree->key))
                tree = tree->right;
            else
                return;

        }
        node = bstree_create(key,value);
        if(0 > strcmp(key,parent->key))
            parent->left = node;
        else
            parent->right = node;
    }
###
struct bstree *find_child(struct bstree *tree,char *key,int *a)
{
    if (tree == NULL)
        return NULL;
    struct bstree *child, *node;
    node = bstree_lookup(tree,key);
    child = node->left;
    *a = 0;
    if(child != NULL)
    {   
        *a = *a+1;
        return child;
    }
    child = node->right;
    if(child != NULL)
    {   
        *a = *a+2;
        return child;
    }
}
###
struct bstree *find_parent(struct bstree *tree,char *key,int *side)
{
    if (tree == NULL)
         return NULL;
    struct bstree *parent;
    while(tree != NULL) {
        if(0 == strcmp(key,tree->key)){
            tree = parent;
            return tree;
        }
        parent = tree;
        if(0 > strcmp(key,tree->key))
        {
            tree = tree->left;
            *side = 1;
        }
        else
        {
            tree = tree->right;
            *side = 0;
        }
    }
    return tree;
}
###
void bstree_delete(struct bstree *tree,char *key)
{
    if(tree ==NULL)
        return;
    struct bstree *parent, *node, *child, *node2;
    int *side,*side2;
    int b = 0,a = 2;
    side = &a;
    side2 = &b;
    node = bstree_lookup(tree,key);
    parent = find_parent(tree,key,side);
    child = find_child(tree,key,side2);
    printf("%d",b);
    
    if(b == 3){
       node2 = bstree_min(node->right);
       node = node2;
       parent = find_parent(tree,node2->key,side);
       parent->left = node2->left;
       free(node2);

    }

    if(b == 2){
        free(node);
        parent->right = child;
        return;
    }
    if(b == 1){
        free(node);
        parent->left = child;
        return;
    }
    if(a == 0){
        parent->right = NULL;
        free(node);
        return;
    }
    if(a == 1){
        parent->left = NULL;
        free(node);
        return;
    }
}
###
int main(){
    
    struct bstree *tree, *node;

    char *str[200000];
    double time1,time2,time;
    FILE *f;
    int *a;
    int b = 10;
    a = &b;
    char *c;
    int N = 237742;
    f = fopen("text.txt", "r");
    for(int i = 0;i < 200000;i++){
        str[i] = malloc(128);
        fscanf(f,"%127s",str[i]);
    }
    printf("%s\n",str[0]);
    tree = bstree_create("bstree",100);
    for(int i = 1;i < 200000;i++)
    {
      bstree_add(tree,str[i-1],i-1);
    }
    time1 = wtime();
    node = bstree_max(tree);
    time2 = wtime();
    time = time2-time1;
    printf("%s\n",node->key);  
    printf("%.9lf\n",time); 
}
###
#include <iostream>

using namespace std;

int main () {

    int *m;

    m = (int*)malloc(10*10*sizeof(int));

    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            *(m + i*10 + j) = 0;
        }
    }

    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {
            cout << *(m + i*10 + j) << " ";
            if (j == 9)
                cout << "\n";
        }
    }

    return 0;
}
###
#include <iostream>

using namespace std;

int main () {

    int **m;
    int i, j;

    m = (int**)malloc(10*sizeof(int*)); 

    for (i = 0; i < 10; i++) {
        m[i] = (int*)malloc(10*sizeof(int));
    }

    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 10; j++)
        {
            m[i][j] = 0;
        }
    }

    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 10; j++)
        {
            cout << m[i][j] << "  ";
            if (j == 9)
                cout << "\n";
        }
    }

    return 0;
}
###
#include <stdio.h>
#include <stdlib.h>

int main () {
    int i = 0;
    char **words = NULL;
    words = (char **)malloc(20*sizeof(char*));

    FILE *str, *out;
    str = fopen("text.txt", "r");

    while (!feof(str)) {
        words[i] = (char *)malloc(25 * sizeof(char));
        fgets(words[i], 25, str);
        i++;
    }

    fclose(str);

    out = fopen("write.txt", "w");

    for (int j = 0; j < 10; j++) {
        fprintf(out, "%s", words[j]);
    }
}
###
#include <iostream>
#include <fstream>

using namespace std;

int main() {

    unsigned int counter = 0;

    char **words = (char**)malloc(20*sizeof(char*));

    ifstream in;
    in.open("symbols.txt");

    ofstream out;
    out.open("written.txt");

    while(in) {
        cout << counter << "\n";
        words[counter] = (char *) malloc(20 * sizeof(char));
        if (in.eof())
            break;
        in.getline(words[counter], 15);
        out << words[counter] << "\n";

        counter ++;
    }

    in.close();
    out.close();

    cout << "REZ : " << words[0] << "\n";

    free(words);

}
###